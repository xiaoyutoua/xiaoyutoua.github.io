<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>灵神基础算法精讲（一） | 小漁头|小戴</title><meta name="author" content="小漁头&amp;小戴"><meta name="copyright" content="小漁头&amp;小戴"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="动态规划还是不会？？？看这里🤓">
<meta property="og:type" content="article">
<meta property="og:title" content="灵神基础算法精讲（一）">
<meta property="og:url" content="http://blog.dai2yutou.space/2023/06/07/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="小漁头|小戴">
<meta property="og:description" content="动态规划还是不会？？？看这里🤓">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbed.dai2yutou.space/web_img/28.png">
<meta property="article:published_time" content="2023-06-07T15:58:25.000Z">
<meta property="article:modified_time" content="2023-07-17T15:56:25.828Z">
<meta property="article:author" content="小漁头&amp;小戴">
<meta property="article:tag" content="💭💡🎈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed.dai2yutou.space/web_img/28.png"><link rel="shortcut icon" href="/img/basketball.png"><link rel="canonical" href="http://blog.dai2yutou.space/2023/06/07/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小漁头&小戴","link":"链接: ","source":"来源: 小漁头|小戴","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '灵神基础算法精讲（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-17 23:56:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/css.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/at.alicdn.com/t/c/font_3829236_a49e40pee5.css"><link rel="stylesheet" href="/css/font-awesome.css"><link rel="stylesheet" href="/css/progress_bar.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/color.css"><link rel="apple-touch-icon" href="/img/apple-touch-icon.jpg"><meta name="apple-mobile-web-app-title" content="小漁头🏀"><link rel="bookmark" href="/img/apple-touch-icon.jpg"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/apple-touch-icon.jpg" ><link rel="stylesheet" href="/css/card_author.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (ture) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.dai2yutou.space/"><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw hide"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><span> 📦归档</span></a></li><li><a class="site-page child" href="/tags/"><span> 🔖标签</span></a></li><li><a class="site-page child" href="/categories/"><span> 📂分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw hide"></i><span> 万花筒</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%94%A0%E5%97%91/"><span> 💭唠嗑</span></a></li><li><a class="site-page child" href="/HTML/%E6%96%B0%E5%B9%B4%E5%80%92%E8%AE%A1%E6%97%B6/index.html"><span> 🔐项目</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/love/"><span> 恋爱小屋</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E8%A3%85%E4%BF%AE%E6%97%A5%E5%BF%97/"><span> ⏰装修日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picbed.dai2yutou.space/web_img/28.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小漁头|小戴</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.dai2yutou.space/"><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw hide"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><span> 📦归档</span></a></li><li><a class="site-page child" href="/tags/"><span> 🔖标签</span></a></li><li><a class="site-page child" href="/categories/"><span> 📂分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw hide"></i><span> 万花筒</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%94%A0%E5%97%91/"><span> 💭唠嗑</span></a></li><li><a class="site-page child" href="/HTML/%E6%96%B0%E5%B9%B4%E5%80%92%E8%AE%A1%E6%97%B6/index.html"><span> 🔐项目</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/love/"><span> 恋爱小屋</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E8%A3%85%E4%BF%AE%E6%97%A5%E5%BF%97/"><span> ⏰装修日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">灵神基础算法精讲（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T15:58:25.000Z" title="发表于 2023-06-07 23:58:25">2023-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-17T15:56:25.828Z" title="更新于 2023-07-17 23:56:25">2023-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="灵神基础算法精讲（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/28.png" style="border-radius:10px" width="1000px"></img><div class="tag link"><a class="link-card" title="灵茶山艾府" target="_blank" rel="noopener" href="https://leetcode.cn/u/endlesscheng/"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.cn/aliyun-lc-upload/users/endlesscheng/avatar_1675227068.png?x-oss-process=image%2Fformat%2Cwebp"/></div><div class="right"><p class="text">灵茶山艾府</p><p class="url">https://leetcode.cn/u/endlesscheng/</p></div></a></div></p>
<div class="note success simple"><p>小戴别偷看了🤣，我发现你了哦~😜</p>
</div>

<div class="note warning flat"><p>💭💡🎈主要是将问题转化为模型的思路！！！</p>
</div>

<h1 id="一、同向双指针【滑动窗口】"><a href="#一、同向双指针【滑动窗口】" class="headerlink" title="一、同向双指针【滑动窗口】"></a>一、同向双指针【滑动窗口】</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.999.0.0&vd_source=e459c0ddead0fb5eb6a33630a090aa93">同向双指针 滑动窗口【基础算法精讲 01】_哔哩哔哩_bilibili</a></p>
<p>子数组和子串问题中经常会用到双指针这一技巧。</p>
<h2 id="来一个例题："><a href="#来一个例题：" class="headerlink" title="来一个例题："></a>来一个例题：</h2><details class="folding-tag" blue><summary> 209.长度最小的子数组 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（Leetcode）</a></p><p>🎈<strong>题目重点词语：</strong></p><ul><li>连续子数组</li><li>元素都是正数</li><li>子数组元素之和大于<code>target</code></li></ul><p><strong>🎈思路</strong></p><p><strong>暴力做法：</strong></p><p>枚举子数组的左端点，不断向右扩展，在扩展的同时，把这些数都加起来，如果还没有达到<code>target</code>，就继续向右扩展，直到达到<code>target</code>为止，当然也是可以枚举右端点的，不断向左扩展，这样做的时间复杂度是$O(n^2)$【枚举每个右端点+每个端点向右扩展$O(n)$】，但此做法并没有利用到数组元素都是正数这个性质。</p><p><strong>时间优化一下：</strong></p><p>那么如何利用数组元素都是<font color='red'>正数</font>的这个性质呢？</p><p>我们可以保留上一次计算的结果，比如之前枚举右端点的时候向左扩展。</p><blockquote><p>[2,3,1,2,4,3]，target&#x3D;7</p><p>当枚举到2的时候，向左扩展到[2,3,1,2]，此时大于了7，那么此时我们就不用重新枚举下一个右端点4了，直接在[2,3,1,2]的基础上直接将4加进去，变成了[2,3,1,2,4]，由于数组都是正数，当[2,3,1,2]$\geq$7的时候，[2,3,1,2,4]肯定也是$\geq$7的，那么此时我们可以不断向右缩小左端点，变成了[3,1,2,4]，如果此时这四个数还是$\geq$7的，那么继续缩小，当发现是$\leq$7的，那么就不需要继续缩小了，因为剩下的肯定也是$\leq$的。</p><p>就是能扔就扔，不能扔就加。</p></blockquote><p>子数组的右端点是我们从左到右枚举的，是$O(n)$的，子数组的左端点我们是在不断缩小的，也是$O(n)$的，那么这个算法的时间复杂度就是$O(n)$的了。</p><p>🎈<strong>code：</strong></p><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#code-1">方法1</button></li><li class="tab"><button type="button" data-href="#code-2">方法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="code-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n+<span class="number">1</span>   <span class="comment"># 初始化结果，方便后面min用，也可也是inf无穷大</span></span><br><span class="line">        s = <span class="number">0</span>   <span class="comment"># 初始化子数组的和</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 初始化左端点</span></span><br><span class="line">        <span class="keyword">for</span> right,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):	<span class="comment"># 枚举右端点</span></span><br><span class="line">            s+=x</span><br><span class="line">            <span class="keyword">while</span> s-nums[left]&gt;=target:	<span class="comment"># 寻找缩小左端点的条件</span></span><br><span class="line">                s-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s&gt;=target:	<span class="comment"># 判断是否更新ans，因为初始的时候s比较小，所以需要判断，下面的放在while循环里面了，就不需要判断了</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans&lt;=n <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>虽然我们写了一个二重循环，但时间复杂度其实不是$O(n^2)$的。</p><p>注意到left+&#x3D;1的次数至多是n次，那因此这个二重循环的时间复杂度也可以理解成是left+&#x3D;1的次数以及right+&#x3D;1的次数，那么这个二重循环的<strong>时间复杂度</strong>就是$O(n)+O(n)$。</p><p><strong>空间复杂度：</strong>$O(1)$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="code-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n+<span class="number">1</span>   <span class="comment"># 初始化结果，方便后面min用，也可也是inf无穷大</span></span><br><span class="line">        s = <span class="number">0</span>   <span class="comment"># 初始化子数组的和</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 初始化左端点</span></span><br><span class="line">        <span class="keyword">for</span> right,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s+=x</span><br><span class="line">            <span class="keyword">while</span> s&gt;=target:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">                s-=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans&lt;=n <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>🎈<strong>双指针应用场景：</strong></p><p>在<code>left</code>移动时，子数组的和是不断变小的，<code>while</code>条件，就从满足要求不断的变化，变成不满足要求的，这就是单调性，只有满足了单调性，我们才可以使用双指针。那么<code>while</code>也可以从不满足要求到满足要求~。</p>
              </div>
            </details>

<h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><details class="folding-tag" blue><summary> 713.长度最小的子数组 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组 - 力扣（Leetcode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubarrayProductLessThanK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        prod = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> right,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            prod*=x</span><br><span class="line">            <span class="keyword">while</span> prod&gt;=k:</span><br><span class="line">                prod /= nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans+=right-left+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 3.无重复字符的最长子串 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（Leetcode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span>     <span class="comment"># 最长子串的长度</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 左指针</span></span><br><span class="line">        cnt = Counter()  <span class="comment"># 一个hashmap，用来计算字符出现次数</span></span><br><span class="line">        <span class="comment"># 因为我们每次加入新的字符的时候，都是在不含重复字符的子串中加入的，所以出现重复了只能是新加入的字符</span></span><br><span class="line">        <span class="keyword">for</span> right,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):    <span class="comment"># 枚举右端点</span></span><br><span class="line">            cnt[c]+=<span class="number">1</span>   <span class="comment"># 计数器+1</span></span><br><span class="line">            <span class="keyword">while</span> cnt[c]&gt;<span class="number">1</span>: <span class="comment">#出现重复，就要将左端点右移，直到不出现重复为止【即直到将和c一样的字符去除了，因为这里的子串肯定是连续的】</span></span><br><span class="line">                cnt[s[left]]-=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,right-left+<span class="number">1</span>) <span class="comment"># 更新答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n)$【和之前一样】</p><p><strong>空间复杂度：</strong>$O(1)&#x2F;O(1)$【s字符串是由字符、下划线、数字组成，所以就直接可以看成ASCII字符，那么ASCII字符有128个，那么就用到了128个空间最多，或者就是s去重之后的长度】</p>
              </div>
            </details>

<details class="folding-tag" blue><summary> 1004. 最大连续1的个数 III </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III - 力扣（Leetcode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span>     <span class="comment"># 初始化结果</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 左指针</span></span><br><span class="line">        <span class="keyword">for</span> right,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): <span class="comment"># 枚举右端点</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="number">0</span>:    <span class="comment"># 如果加进去了0，那么k需要-1</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k&lt;<span class="number">0</span>:  <span class="comment">#判断条件0的个数是否大于k了，大于了左端点就右移，直到正好有k个0</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] == <span class="number">0</span>:</span><br><span class="line">                    k+=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)     <span class="comment"># 更新结果</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 1234. 替换子串得到平衡字符串 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solutions/2108358/tong-xiang-shuang-zhi-zhen-hua-dong-chua-z7tu/">1234. 替换子串得到平衡字符串 - 力扣（Leetcode）</a></p><p><font color='red'>逆向思考💡</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balancedString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, m = Counter(s), <span class="built_in">len</span>(s) // <span class="number">4</span></span><br><span class="line">        <span class="comment"># cnt是用来统计待替换子串外的各字符个数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(cnt[x] == m <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;QWER&quot;</span>):  <span class="comment"># 已经符合要求啦</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans, left = inf, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):  <span class="comment"># 枚举子串右端点</span></span><br><span class="line">            cnt[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">all</span>(cnt[x] &lt;= m <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;QWER&quot;</span>):</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">                cnt[s[left]] += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 缩小子串</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 1658. 将 x 减到 0 的最小操作数 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III - 力扣（Leetcode）</a></p><p><font color='red'>逆向思考💡</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        target = <span class="built_in">sum</span>(nums) - x</span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 全部移除也无法满足要求</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        left = s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s += x</span><br><span class="line">            <span class="keyword">while</span> s &gt; target:  <span class="comment"># 缩小子数组长度</span></span><br><span class="line">                s -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(nums) - ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 2516. 每种字符至少取 K 个 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/">2516. 每种字符至少取 K 个 - 力扣（Leetcode）</a></p><p><font color='red'>逆向思考💡</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">takeCharacters</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 逆向思维</span></span><br><span class="line">        <span class="comment"># 取一个连续的子串</span></span><br><span class="line">        <span class="comment"># 题目要求每个字符至少取k次，即&gt;=k</span></span><br><span class="line">        <span class="comment"># 那么我们取一个连续的字符串，看剩下的字符个数是不是满足&gt;=k的</span></span><br><span class="line">        <span class="comment"># 那么就是求最长的子串长度</span></span><br><span class="line">        <span class="comment"># 结果就是len(nums)-k</span></span><br><span class="line">        cnt = Counter(s)    <span class="comment"># 统计剩余字符串的每个字符的个数</span></span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 左指针</span></span><br><span class="line">        ans = <span class="number">0</span> <span class="comment"># 最大连续子串的长度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(cnt[x]&gt;=k <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>):   <span class="comment"># 如果不是都&gt;=k的直接return -1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> right,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            cnt[c]-=<span class="number">1</span>   <span class="comment"># 取一个了</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">all</span>(cnt[x]&gt;=k <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>):    <span class="comment"># 判断是否满足要求，不满足左指针右移</span></span><br><span class="line">                cnt[s[left]]+=<span class="number">1</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)-ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h1 id="二、相向双指针"><a href="#二、相向双指针" class="headerlink" title="二、相向双指针"></a>二、相向双指针</h1><details class="folding-tag" blue><summary> 167. 两数之和 II - 输入有序数组 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 - 力扣（Leetcode）</a></p><p>🎈<strong>题目重点词语</strong></p><ul><li>数组是非递减的！</li></ul><p>🎈<strong>思路：</strong></p><p><strong>暴力解法</strong></p><p>枚举第一个数，然后再枚举第二个数，两个for循环嵌套</p><p>时间复杂度$O(n^2)$</p><p><strong>优化一下</strong></p><p>数组是排好序的，但暴力解法并没有利用到数组是排好序这个性质。</p><p>如何利用？</p><blockquote><p>[2,3,4,6,8]	targey&#x3D;9</p><p>随便选择两个数，比如3和8，3+8&gt;9了</p><p>因为数组有序，既然3+8已经大于9了，那么3和8中间的数组4、6与8的和，肯定也是大于9的。</p><p>那么如何利用这个特点呢？</p><p>我们首先就可以先将最小的数2和最大的数8相加，2+8&gt;9，那么2和8中间的数和8相加肯定也是大于9的，那么我们就可以直接将8去掉了，在剩下的四个数中进行选择。</p><p>2和6的和小于，那么就意味着2和6之间的数字和2的和肯定都是小于9的，那么就可以直接把2去掉了。</p></blockquote><p>那么这样的<strong>时间复杂度</strong>是多少呢？</p><p>我们每次只花费$O(1)$的时间将两个数相加与target比较大小，就可以去掉一个数，直到找到答案，因此算法的时间复杂度就是$O(n)$的。</p><p>那么这个算法相比暴力算法到底是快在哪里？</p><p>这里用一个获取了多少的信息量来衡量一个算法的效率，</p><ul><li>暴力做法花费O(1)的时间只知道了O(1)的信息。</li><li>优化后的做法花费O(1)的时间知道了O(n)的信息。</li></ul><p>🎈<strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left = <span class="number">0</span>    <span class="comment"># 左指针</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span>      <span class="comment"># 右指针</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            s = numbers[left]+numbers[right]</span><br><span class="line">            <span class="keyword">if</span> s==target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> s&gt;target:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [left+<span class="number">1</span>,right+<span class="number">1</span>]     <span class="comment"># 题目要求数组下标从1开始</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 15. 三数之和 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（Leetcode）</a></p><p>🎈<strong>题目重点词语：</strong></p><ul><li>三元组顺序不重要</li><li>三元组不能重复</li><li><code>i&lt;j&lt;k</code></li></ul><p>🎈<strong>思路：</strong></p><p>既然题目说三元组顺序不重要，那么就是[-1,0,1]和[-1,1,0]是一样的，那么我们不妨先排下序，然后自己规定一个顺序，即规定<code>i&lt;j&lt;k</code>，然后将<code>nums[i]+nums[j]+nums[k]=0</code>转换成<code>nums[j]+nums[k]=-nums[i]</code>，那也就将此题转换成了两数之和【我们枚举-nums[i],然后将j和k相加成了两数之和】。</p><p>注意还有一点就是答案中不可以包含重复的三元组，因为这里的元素会重复，这里和两数之和是不一样的。</p><blockquote><p>[-4,-1,-1,0,1,2]</p><p>当枚举到第二个数-1的时候，[-1,0,1]符合要求</p><p>当第三个数的时候，[-1,0,1]也是符合要求的，这样就会出现重复，那么该怎么办呢？</p><p>因为我们已经将数组排好序，我们只需要判断一下当前枚举的这个数是否和上一个数相同，相同则跳过。</p></blockquote><p>🎈<strong>code：</strong></p><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#code-1">与两数之和相联系</button></li><li class="tab"><button type="button" data-href="#code-2">优化一下</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="code-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []    <span class="comment"># 初始化结果</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):    <span class="comment"># 枚举nums[i]</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 如何当前枚举的和前一个数相同，那么跳过</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i+<span class="number">1</span>     <span class="comment"># 左指针</span></span><br><span class="line">            k = n-<span class="number">1</span>     <span class="comment"># 右指针</span></span><br><span class="line">            <span class="keyword">while</span> j&lt;k:  <span class="comment"># 循环找到s=0的i,j,k</span></span><br><span class="line">                s = nums[i]+nums[j]+nums[k]</span><br><span class="line">                <span class="keyword">if</span> s&gt;<span class="number">0</span>:</span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s&lt;<span class="number">0</span>:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i],nums[j],nums[k]])</span><br><span class="line">                    <span class="comment"># 这里还需要判断一下j和k是否重复</span></span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j&lt;k <span class="keyword">and</span> nums[j]==nums[j-<span class="number">1</span>]:    <span class="comment"># 刚才j+1了,判断一下是否重复，下面k也是</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j&lt;k <span class="keyword">and</span> nums[k]==nums[k+<span class="number">1</span>]:</span><br><span class="line">                        k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>nums.sort()：排序的时间复杂度是$O(nlog_n)$，后面的嵌套循环中，枚举<code>nums[i]</code>是$O(n)$的，双指针也是$O(n)$的，所以是$O(n^2)$。</p><p><strong>空间复杂度：</strong></p><p>排序不算，就是$O(1)$。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="code-2"><p>注意我们枚举的是nums[i]</p><ul><li>当枚举第i个数的时候，如果他与后面的两个数的和都大于0了，那么就不必再继续往后枚举了，因为数组是递增的，直接break。</li><li>当第i个数与最后两个数的和都小于0了，那么他肯定与前面的数的和也小于0，直接continue，枚举下一个nums[i]。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []    <span class="comment"># 初始化结果</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):    <span class="comment"># 枚举nums[i]</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 如何当前枚举的和前一个数相同，那么跳过</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[-<span class="number">2</span>]+nums[-<span class="number">1</span>]&lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i+<span class="number">1</span>     <span class="comment"># 左指针</span></span><br><span class="line">            k = n-<span class="number">1</span>     <span class="comment"># 右指针</span></span><br><span class="line">            <span class="keyword">while</span> j&lt;k:  <span class="comment"># 循环找到s=0的i,j,k</span></span><br><span class="line">                s = nums[i]+nums[j]+nums[k]</span><br><span class="line">                <span class="keyword">if</span> s&gt;<span class="number">0</span>:</span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s&lt;<span class="number">0</span>:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i],nums[j],nums[k]])</span><br><span class="line">                    <span class="comment"># 这里还需要判断一下j和k是否重复</span></span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j&lt;k <span class="keyword">and</span> nums[j]==nums[j-<span class="number">1</span>]:    <span class="comment"># 刚才j+1了,判断一下是否重复，下面k也是</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j&lt;k <span class="keyword">and</span> nums[k]==nums[k+<span class="number">1</span>]:</span><br><span class="line">                        k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
              </div>
            </details>

<p><strong>相关题目：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-triangle-number/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">611. 有效三角形的个数 - 力扣（Leetcode）</a></li>
</ul>
<details class="folding-tag" blue><summary> 11. 盛最多水的容器 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qg411q7ia/?p=3&spm_id_from=pageDriver">盛最多水的容器 接雨水【基础算法精讲 03】_哔哩哔哩_bilibili</a></p>
              </div>
            </details>

<details class="folding-tag" blue><summary> 42. 接雨水 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qg411q7ia/?p=3&spm_id_from=pageDriver">盛最多水的容器 接雨水【基础算法精讲 03】_哔哩哔哩_bilibili</a></p><p>可以用前后缀分解，也可以用双指针。</p>
              </div>
            </details>

<h1 id="三、二分查找"><a href="#三、二分查找" class="headerlink" title="三、二分查找"></a>三、二分查找</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">二分查找【基础算法精讲 04】_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QK411d76w/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">搜索旋转排序数组【基础算法精讲 05】_哔哩哔哩_bilibili</a></p>
<h2 id="💡循环不变量："><a href="#💡循环不变量：" class="headerlink" title="💡循环不变量："></a>💡循环不变量：</h2><details class="folding-tag" blue><summary> 例题 </summary>
              <div class='content'>
              <p><strong>关于区间有以下四种情况：</strong></p><ul><li>左闭右闭区间</li><li>左闭右开区间</li><li>左开右闭区间</li><li>左开右开区间</li></ul><p><strong>关于比较有五种情况：</strong></p><ul><li>$&#x3D;、&gt;、\geq、&lt;、\leq$</li></ul><p><strong>下面解释一种情况</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/9.png" alt="1"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/10.png" alt="1"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/11.png" alt="1"></p><blockquote><p>💭<strong>红蓝染色法</strong></p><p>就是定一下目标值，看在目标值的左侧还是右侧，左侧红色，右侧蓝色；</p><p>二段性：每次都能判断答案在一个位置的左边或者右边就行了；</p><p>注意不一定必须有序，分析题目，只要能得到答案就可。</p></blockquote><div class="tabs" id="🎈code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#🎈code-1">左闭右闭</button></li><li class="tab"><button type="button" data-href="#🎈code-2">左闭右开</button></li><li class="tab"><button type="button" data-href="#🎈code-3">左开右开</button></li><li class="tab"><button type="button" data-href="#🎈code-4">其他情况</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="🎈code-1"><p>寻找$\geq$target的第一个位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 左右指针，这里是闭区间 [0,n-1]</span></span><br><span class="line">    left,right = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:  <span class="comment"># 区间不为空</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># c++ 防止溢出，可以这么写：left+(right-left)/2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target:    <span class="comment"># 说明mid以前全部小于target</span></span><br><span class="line">            left = mid+<span class="number">1</span>    <span class="comment"># [mid+1,right]</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 说明mid以后的都大于等于target</span></span><br><span class="line">            right = mid-<span class="number">1</span>:  <span class="comment"># [left,mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> left     <span class="comment"># 这里求的是大于等于target的位置，所有最后的情况肯定是right在mid左边，left在mid上，所有right=mid-1，left=mid</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="🎈code-2"><p>寻找$\geq$target的第一个位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 左闭右开  # [left,right)</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> left&lt;right:   <span class="comment"># 区间不为空    当left = right的时候,区间已经是空了</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid     <span class="comment"># 开区间，[left,mid) --&gt; [left,mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> left     <span class="comment"># 此时left=right</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="🎈code-3"><p>寻找$\geq$target的第一个位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 左开右开  # (left,right)</span></span><br><span class="line">    left = -<span class="number">1</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> left+<span class="number">1</span>&lt;right:   <span class="comment"># 区间不为空    当left+1 = right的时候,区间已经是空了,退出循环</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">            left = mid  <span class="comment"># 开区间，（mid,right) --&gt; [mid+1,right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid     <span class="comment"># 开区间，(left,mid) --&gt; (left,mid-1]</span></span><br><span class="line">    <span class="keyword">return</span> right     <span class="comment"># 此时left+1=right</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="🎈code-4"><ul><li>$&gt;和&#x3D;$：就是$\geq$情况，等于号放在<code>nums[mid]&lt;target</code>这里</li><li>$&lt;$：改变最终的return值就好</li><li>$\leq$：改变最终的return值就好</li></ul><p>具体情况具体分析！！！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="💡相关题目"><a href="#💡相关题目" class="headerlink" title="💡相关题目"></a>💡相关题目</h2><p><a target="_blank" rel="noopener" href="https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/sort.go">二分查找的题单</a></p><ul><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（Leetcode）</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值 - 力扣（Leetcode）</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值 - 力扣（Leetcode）</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组 - 力扣（Leetcode）</a>有点难啊😭</li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II - 力扣（Leetcode）</a></li></ul>
              </div>
            </details>

<h1 id="四、链表"><a href="#四、链表" class="headerlink" title="四、链表"></a>四、链表</h1><p>💡可能会有比较奇怪的做法哦！好好思考</p>
<h2 id="4-1-反转链表"><a href="#4-1-反转链表" class="headerlink" title="4.1 反转链表"></a>4.1 反转链表</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sd4y1x7KN/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">反转链表【基础算法精讲 06】_哔哩哔哩_bilibili</a></p>
</blockquote>
<p>在表头添加一个节点！！！</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表 - 力扣（Leetcode）</a></li>
</ul>
<h2 id="4-2-快慢指针"><a href="#4-2-快慢指针" class="headerlink" title="4.2 快慢指针"></a>4.2 快慢指针</h2><p>一般快指针的移动速度是慢指针的两倍！！！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KG4y1G7cu/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">环形链表II【基础算法精讲 07】_哔哩哔哩_bilibili</a></p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">876. 链表的中间结点 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/">141. 环形链表 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>多做做，多分析分析，数学思维💭</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/description/">143. 重排链表 - 力扣（Leetcode）</a></p>
<p>多做！！！</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/description/">234. 回文链表 - 力扣（Leetcode）</a></p>
</li>
</ul>
<h2 id="4-3-前后指针"><a href="#4-3-前后指针" class="headerlink" title="4.3 前后指针"></a>4.3 前后指针</h2><p>后指针先走，前指针随后跟着！！!</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VP4y1Q71e/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">删除链表重复节点【基础算法精讲 08】_哔哩哔哩_bilibili</a></p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">237. 删除链表中的节点 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82. 删除排序链表中的重复元素 II - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（Leetcode）</a></li>
</ul>
<h1 id="五、二叉树"><a href="#五、二叉树" class="headerlink" title="五、二叉树"></a>五、二叉树</h1><p>动态演示网站：<a target="_blank" rel="noopener" href="https://pythontutor.com/">https://pythontutor.com/</a></p>
<h2 id="5-1-二叉树的递归【计算机执行递归底层原理】"><a href="#5-1-二叉树的递归【计算机执行递归底层原理】" class="headerlink" title="5.1 二叉树的递归【计算机执行递归底层原理】"></a>5.1 二叉树的递归【计算机执行递归底层原理】</h2><p>💡<strong>在开头首先要知道到底什么是递归？？？</strong></p>
<p>递归是一种在函数或过程中调用自身的编程技巧。在函数定义中，递归指的是在函数内部调用自身的方式。</p>
<p>递归的核心思想是“有去有回”。在递归过程中，问题会被分解成若干个规模更小的相似子问题，这些子问题和原问题有着相同的解法。通过不断地递归，问题的规模逐渐缩小，直到达到一个可以直接求解的边界条件，然后通过递归的方式逐步返回，最终得到问题的解。</p>
<p>递归通常包括以下四个基本步骤：</p>
<ol>
<li>边界条件（终止条件）：确定递归何时结束，通常是某些简单的情况或条件。</li>
<li>递归前进段：定义在满足边界条件之前的递归过程，通常是通过调用函数自身来实现。</li>
<li>递归返回段：定义在满足边界条件时的返回操作，通常是将结果返回给递归前进段使用的函数。</li>
<li>递归辅助函数：将递归前进段和递归返回段结合在一起的函数，它定义了如何处理递归过程中的每个步骤。</li>
</ol>
<p>在计算机科学和数学中，递归常用于解决一些复杂的问题，如树的遍历、排序算法、图形处理、分治算法等。然而，在使用递归时需要注意避免死循环和栈溢出等问题，以确保程序的正确性和稳定性。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UD4y1Y769/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">计算机是怎么执行递归的？二叉树的最大深度【基础算法精讲 09】_哔哩哔哩_bilibili</a></p>
<p>处理递归，不要想子问题的过程，只要想子问题的结果，思路就清晰了❗。</p>
<p>只要代码的边界条件和非边界条件的逻辑写对了，代码必然正确，没有必要想递归是怎么一层一层走的❗。</p>
</blockquote>
<details class="folding-tag" blue><summary> 求二叉树的最大深度 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><p>🎈<strong>思路：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/15.png" alt="1"></p><p>不要一开始就陷入二叉树的细节，可以把二叉树简化成如下图示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/12.png" alt="1"></p><p>这里用三角形表示子树</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/13.png" alt="1"></p><p>在这个问题中，我们的问题是有嵌套关系的，我们需要把我们的计算结果返回给它的上一级问题，而它的上一级问题又会把它的计算结果返回给上上一级问题，从这个角度看，用递归实现更合适</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/14.png" alt="1"></p><p>我们从原问题出发，把问题不断分解成更小的子问题，这就是【递归】过程中的【递】过程，那么不断的递归下去总会有个尽头，也就是递归的边界条件，在这个问题中，递归的边界条件就是空节点，我们可以直接返回0作为答案，那么这个返回的过程就是【递归】中的【归】。</p><p>🎈<strong>为什么这样做就肯定是对的呢？？？</strong></p><p>可以用数学归纳法</p><p>🎈<strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l_depth = self.maxDepth(root.left)</span><br><span class="line">        r_depth = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l_depth,r_depth)+<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：</p><p>$O(n)$，每个节点都遍历了一次，</p></li><li><p>空间复杂度：</p><p>$O(n)$，</p><p>当我们<code>return </code>的时候，这个节点怎么知道它要<code>return</code>到哪个节点上去呢？</p><p>计算机递归的时候，有一个递归栈，在递的时候，会记录节点，然后在归的时候，会依次取出节点，返回给此对应的节点，即就是支持先进后出。在最坏情况下，二叉树只有左儿子，没有右儿子，就变成了一个链状的结构，这个栈的大小就会达到$O(n)$</p></li></ul><p>🎈<strong>另一种方法：</strong></p><p>在递归的时候，除了把节点传下去，还可以把路径上的节点个数也 传下去。</p><p>根节点这里肯定是1，它把1传下去，递归左子树，把刚才收到的1，再+1得到2，那递归右子树也是一样的，然后右子树再递归，把2传下去，+1后变成了3，我们在递归的同时呢，维护一个全局变量，每次加完1之后，就更新全局变量的最大值，递归结束之后，答案就是此全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, cnt</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt)</span><br><span class="line">            dfs(node.left, cnt)</span><br><span class="line">            dfs(node.right, cnt)</span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>💡<strong>相关题目：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和 - 力扣（Leetcode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（Leetcode）</a></li>
</ul>
<h2 id="5-2-如何灵活的运用递归？？？"><a href="#5-2-如何灵活的运用递归？？？" class="headerlink" title="5.2 如何灵活的运用递归？？？"></a>5.2 如何灵活的运用递归？？？</h2><details class="folding-tag" blue><summary> 相同的树 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树 - 力扣（Leetcode）</a></p><p>如何判断两棵树相同呢？？？</p><ul><li>首先，根节点肯定是相同的</li><li>那么如果根节点相同了，左右两个子树要是也相同，那么这两棵树肯定是相同的</li><li>那么如何判断左右两颗子树也相同呢？递归是最好的办法了❗</li><li>边界条件是什么？？？</li><li>只要其中一颗子树是空的，那么肯定无法递归下去了，这时判断两颗子树是不是同时为空就可以</li></ul><p><strong>code：</strong></p><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#code-1">Python</button></li><li class="tab"><button type="button" data-href="#code-2">c++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="code-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">return</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> q <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 下面判断当前节点是否相同</span></span><br><span class="line">        <span class="keyword">if</span> p.val == q.val:  <span class="comment"># 相同</span></span><br><span class="line">            <span class="comment"># 递归返回两颗左右子树是否相同，必须都相同，所以是 and</span></span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不相同直接返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="code-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> p==<span class="literal">nullptr</span> &amp;&amp; q==<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) <span class="keyword">and</span> <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
              </div>
            </details>

<details class="folding-tag" blue><summary> 对称二叉树 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（Leetcode）</a></p><p>判断树是否是轴对称</p><p>从中间将树切成两半，题目中树肯定是存在根节点的，且根节点肯定是轴对称的，所有发现和上题一样，这里就是比较根节点的两颗左右子树是否是镜像的，对left和right调换一下就可以了。</p><p>直接调用上题代码：</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">p,q</span>):</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> q <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> p.val==q.val:</span><br><span class="line">                <span class="keyword">return</span> f(p.left,q.right) <span class="keyword">and</span> f(p.right,q.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> f(root.left,root.right)</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 平衡二叉树 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（Leetcode）</a></p><p><strong>平衡二叉树：</strong></p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p>首先利用递归求得每个子树的高度</p><p>这里得到的高度的结果肯定是归的时候得到的，我们定义递归函数的时候，根节点作为入口，然后往叶子节点递，然后归的时候，返回子树的高度。</p><p>然后左右子树相减，判断结果是不是大于1就可</p><p>那这里如果大于1怎么办呢，还往上归吗？？？</p><p>当然不用，这里可以利用高度肯定是非负的性质，如果遇到了不平衡的情况，直接返回-1，每个归的时候判断一下是否为-1，为-1的话，就一直往上返回，直到根节点❗</p><p>最终判断一下递归入口处返回的是不是-1即可❗</p><p><strong>code：</strong></p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 求解树的高度</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_tree_height</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 边界条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>    <span class="comment"># 表明树的高度是0</span></span><br><span class="line">            left_tree_height = get_tree_height(root.left) <span class="comment"># 递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> left_tree_height == -<span class="number">1</span>:  <span class="comment"># 判断是否是-1，即是否是平衡的</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            right_tree_height = get_tree_height(root.right) <span class="comment"># 递归右子树</span></span><br><span class="line">            <span class="keyword">if</span> right_tree_height == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(left_tree_height-right_tree_height)&gt;<span class="number">1</span>:   <span class="comment"># 如果是不平衡的</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>   <span class="comment"># 返回-1</span></span><br><span class="line">            <span class="comment"># 都不符合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_tree_height,right_tree_height)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> get_tree_height(root) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 二叉树的右视图 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图 - 力扣（Leetcode）</a></p><p>这道题该怎么做呢？？？</p><blockquote><p>既然是找右视图，那肯定是最右边的子树最先看到，如果右子树没有，才会看到左子树。</p><p>那我们就可以先递归右子树，再递归左子树。</p><p>那这里有两个问题：</p><ul><li>我们怎么把答案记下来</li><li>我们怎么判断这个节点是否需要记录到答案中</li></ul><p><strong>下面是一个神方法</strong>😭</p><p>在递归的同时记录一个节点个数或者说是递归深度，如果递归深度等于答案【在这里就是一个vector】的长度，那么这个节点就需要记录到答案中【当遍历到此节点的时候，此时的递归深度是不加上此节点的，因为我们要做的就是判断此节点是否加答案中，所有上边是等于❗】</p><p>比如根节点的时候，答案长度为0，递归深度为0，那么此时就可以把根节点加进去。这样就可以将最右边的节点全部加到答案中，左子树中看不到的节点都不会加入到答案中去，然后依次再向左边选取节点加入到答案中。</p></blockquote><p><strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node,depth</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> depth == <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            f(node.right,depth+<span class="number">1</span>)</span><br><span class="line">            f(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        f(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 翻转二叉树 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（Leetcode）</a></p><p>翻转❗</p><p>那就是从根节点开始，如果这个根节点有左右子树其中的一个，那么即交换：注意这里不能交换值，只能交换左右子树。</p><p><strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">or</span> root.right:</span><br><span class="line">            x = root.left</span><br><span class="line">            root.left = root.right</span><br><span class="line">            root.right = x</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" blue><summary> 节点与其祖先之间的最大差值 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值 - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/solutions/2232367/liang-chong-fang-fa-zi-ding-xiang-xia-zi-wj9v/">1026. 节点与其祖先之间的最大差值 - 力扣（Leetcode）</a></p>
              </div>
            </details>

<details class="folding-tag" blue><summary> 根到叶路径上的不足节点 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点 - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/solutions/2278769/jian-ji-xie-fa-diao-yong-zi-shen-pythonj-64lf/">1080. 根到叶路径上的不足节点 - 力扣（Leetcode）</a></p>
              </div>
            </details>

<details class="folding-tag" blue><summary> 删点成林 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-nodes-and-return-forest/">1110. 删点成林 - 力扣（Leetcode）</a></p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-nodes-and-return-forest/solutions/2289131/he-shi-ji-lu-da-an-pythonjavacgo-by-endl-lpcd/">1110. 删点成林 - 力扣（Leetcode）</a></p><p>如何保证递归是从叶子节点开始的呢，只要将操作放在递归的下面，先递归再操作❗❗❗</p>
              </div>
            </details>

<details class="folding-tag" blue><summary> 二叉树的最长交错路径 </summary>
              <div class='content'>
              <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径 - 力扣（Leetcode）</a></p><p><strong>🎈思路：</strong></p><ul><li>从叶子节点开始，往上归</li><li>返回两个数，一个是以当前节点向左交错的路径长度，一个是以当前节点向左交错的路径长度</li><li>如果是空节点，返回-1，-1【因为最长路径长度是访问过的节点长度-1】</li><li>如果是叶子节点，返回的肯定是0，0</li><li>如果不是，那么返回的就是：【当前节点的左孩子向右交错的路径长度+1，当前节点的右孩子向左交错的路径长度+1】</li></ul><p><strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestZigZag</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span> <span class="comment"># 初始化最长交错路径长度</span></span><br><span class="line">        <span class="comment"># 深度优先搜索函数，遍历二叉树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>,-<span class="number">1</span>    <span class="comment"># 这里返回 -1 是因为交错路径长度要-1</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans    <span class="comment"># 声明ans为非局部变量</span></span><br><span class="line">            l1,r1 = dfs(node.left)  <span class="comment"># l1,r1表示从node.left开始向左和向右走的路径长度</span></span><br><span class="line">            l2,r2 = dfs(node.right)</span><br><span class="line">            <span class="comment"># node.left 表示从node向左走，所以这里肯定取r1,才能交错</span></span><br><span class="line">            <span class="comment"># node.right 表示从node向右走，所以这里肯定取l1,才能交错</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="number">1</span>+r1,<span class="number">1</span>+l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+r1,<span class="number">1</span>+l2</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h2 id="5-3-二叉搜索树BST"><a href="#5-3-二叉搜索树BST" class="headerlink" title="5.3 二叉搜索树BST"></a>5.3 二叉搜索树BST</h2><h3 id="（1）什么是二叉搜索树❓"><a href="#（1）什么是二叉搜索树❓" class="headerlink" title="（1）什么是二叉搜索树❓"></a>（1）什么是二叉搜索树❓</h3><p>对于一个节点，它的左子树所有节点的值都小于它，它的右子树的所有节点的值都大于它。</p>
<p>同时它的左子树和右子树也必须是二叉搜索树。</p>
<h3 id="（2）如何判断一棵树是不是二叉搜索树❓"><a href="#（2）如何判断一棵树是不是二叉搜索树❓" class="headerlink" title="（2）如何判断一棵树是不是二叉搜索树❓"></a>（2）如何判断一棵树是不是二叉搜索树❓</h3><p><strong>题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（Leetcode）</a></strong></p>
<ul>
<li><p><strong>前序遍历📌</strong></p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/16.png" alt="1"></p>
<p>根据定义，根节点5的左子树所有节点值必须小于5，那换句话说，这些节点的值都必须在开区间负无穷大到5中($-∞,5$)&#96;</p>
<p>对于2的右子树，那么所有节点的值必须是在(2,5)之间的。</p>
<p>根据此过程，可以提出一个递归算法，在递归的时候，除了传入节点，还需要传入这个开区间的范围；</p>
<p>对于每个节点，首先判断它的节点值是否在开区间内，然后再往下递归，那如果往左边递归，那么就把开区间的有边界更新为节点值，因为此子树所有节点的值肯定是小于父节点的值的。</p>
<p>往右递归，相反处理。</p>
</blockquote>
<p>这种先访问节点值，再递归左右子树的过程，就叫做前序遍历。</p>
<blockquote>
<p>根节点是递归函数调用的入口，再往上是没有节点的，因此传入的值是<code>[-∞,+∞]</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node,left, right</span>):</span><br><span class="line">            <span class="comment"># 首先判断递归的边界条件</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            x = node.val</span><br><span class="line">            <span class="comment"># 开区间范围内</span></span><br><span class="line">            <span class="comment"># 左子树和右子树必须是二叉搜索树</span></span><br><span class="line">            <span class="keyword">return</span> left &lt; x &lt; right <span class="keyword">and</span> dfs(node.left,left,x) <span class="keyword">and</span> dfs(node.right,x,right)</span><br><span class="line">        <span class="comment"># 递归入口根节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root,-inf,inf)</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度都是$O(n)$</p>
</li>
<li><p><strong>中序遍历📌</strong></p>
<p>中序遍历二叉搜索树等于遍历有序数组❗</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/16.png" alt="1"></p>
<p>按照递归左子树、访问节点值、再递归右子树的顺序去遍历，比如上图中【1,2,3,4,5,6】</p>
<p>这样我们就可以得到一个严格的递增数组；</p>
<p>那么如何判断一个数组是严格递增的呢？</p>
<p>只需要比较所有相邻的元素就可以。</p>
<p>对于一个二叉搜索树的中序遍历，每次遍历完左子树，就可以看当前节点的值是否大于上一个节点的值，也就是左子树的根节点的值，然后把当前节点的值记录下来，它的下一个节点值就和它比大小。</p>
</blockquote>
<p><strong>code：</strong></p>
<p>第一个节点没有上一个节点，所有可以初始化上一个节点的值为负无穷大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        pre = -inf</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 首先递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(node.left):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pre</span><br><span class="line">            <span class="keyword">if</span> node.val &lt;= pre: <span class="comment"># 如果当前节点值&lt;=上一个节点的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = node.val  <span class="comment"># 记录当前节点的值</span></span><br><span class="line">            <span class="comment"># 递归右子树</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(node.right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后序遍历📌</strong></p>
<blockquote>
<p>之前讲的前序遍历是把节点的值的范围往下传，那么我们也可以把节点值的范围往上传，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/17.png" alt="1"></p>
<p>比如对于5来说，它左边节点值的范围是[1,4]，右边是[6,6]，那么5大于做左边是最大值，并且5小于右边的最小值，那么这就是合法的。</p>
<p>这种做法需要先遍历左右子树，再判断节点值。</p>
<p>后序遍历时需要返回的是<strong>子树的取值范围</strong>，叶子节点取值范围最小，只有它自身的值，随后不断向上，节点的取值范围慢慢变大，任意一颗子树的取值范围来自于其左子树的最小值和其右子树上的最大值，这样保留了足够多的信息。</p>
<p>这里为什么要返回左子树的最小值，而不是最大值呢？？？</p>
<p>答：注意，这里是从子树向上递归，不是从上向子树往下递归，所有父节点需要得到更多的信息，以确保每个节点都是小于它的祖先节点的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># 首先判断边界条件</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> inf,-inf</span><br><span class="line">            <span class="comment"># 递归左子树，拿到左子树的最小值和最大值</span></span><br><span class="line">            l_min,l_max = dfs(node.left)</span><br><span class="line">            <span class="comment"># 递归右子树，拿到右子树的最小值和最大值</span></span><br><span class="line">            r_min,r_max = dfs(node.right)</span><br><span class="line">            <span class="comment"># 记录节点值</span></span><br><span class="line">            x = node.val</span><br><span class="line">            <span class="keyword">if</span> x &lt;= l_max <span class="keyword">or</span> x &gt;= r_min:    <span class="comment"># 表明这不是一颗二叉搜索树，上面边界条件返回的 inf 和 -inf 可以保证这句话肯定不成立</span></span><br><span class="line">                <span class="comment"># 这里返回 -inf 和 inf可以保证在子树已经不是二叉搜索树的情况下，父节点肯定也不是二叉搜索树</span></span><br><span class="line">                <span class="keyword">return</span> -inf,inf</span><br><span class="line">            <span class="comment"># 最后返回左边的最小值和右边的最大值</span></span><br><span class="line">            <span class="comment"># 由于这里我们会返回inf和-inf，所有要min 和 max</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">min</span>(l_min,x) , <span class="built_in">max</span>(r_max,x)</span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">1</span>] != inf</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（3）二叉搜索树中第k小的元素"><a href="#（3）二叉搜索树中第k小的元素" class="headerlink" title="（3）二叉搜索树中第k小的元素"></a>（3）二叉搜索树中第k小的元素</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素 - 力扣（Leetcode）</a></strong></p>
<p>二叉搜索树的中序遍历会得到一个递增的序列，那么我们就可以利用此性质来求</p>
<p><strong>code：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = []	<span class="comment"># 用来存储已经遍历到的数</span></span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f(node.left)</span><br><span class="line">            <span class="comment"># nonlocal ans</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans)==k:	<span class="comment"># 表明已经找到第k小的数了，所有不往ans添加元素，直接return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            f(node.right)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> ans[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="（4）二叉搜索树中的众数"><a href="#（4）二叉搜索树中的众数" class="headerlink" title="（4）二叉搜索树中的众数"></a>（4）二叉搜索树中的众数</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数 - 力扣（Leetcode）</a></strong></p>
<p>直接利用hash</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root</span>):</span><br><span class="line">        models = []     <span class="comment"># 初始化存储结果的列表</span></span><br><span class="line">        max_count = <span class="number">0</span>   <span class="comment"># 初始化最大值</span></span><br><span class="line">        count = collections.Counter()   <span class="comment"># 计数器</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> max_count</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                f(node.left)    <span class="comment"># 遍历左子树</span></span><br><span class="line">                <span class="comment"># 遍历根节点 +1</span></span><br><span class="line">                count[node.val] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断是否是众数</span></span><br><span class="line">                <span class="keyword">if</span> count[node.val] &gt; max_count: <span class="comment"># 出现数量更多的数，更新models</span></span><br><span class="line">                    max_count = count[node.val]</span><br><span class="line">                    models.clear()</span><br><span class="line">                    models.append(node.val)</span><br><span class="line">                <span class="keyword">elif</span> count[node.val] == max_count:  <span class="comment"># 表述数量一样</span></span><br><span class="line">                    models.append(node.val)</span><br><span class="line">                <span class="comment"># 遍历右子树</span></span><br><span class="line">                f(node.right)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> models</span><br></pre></td></tr></table></figure>

<h3 id="（5）二叉搜索树的最小绝对差"><a href="#（5）二叉搜索树的最小绝对差" class="headerlink" title="（5）二叉搜索树的最小绝对差"></a>（5）二叉搜索树的最小绝对差</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（Leetcode）</a></strong></p>
<p>利用中序遍历得到的递增序列求解。</p>
<p>由于求解的是任意节点的最小差，且差值是正数，那么结果肯定是在利用中序遍历得到的序列中相邻节点的差中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_num = inf     <span class="comment"># 初始化最小值</span></span><br><span class="line">        pre = -inf      <span class="comment"># 初始化上一个值</span></span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> min_num,pre</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f(node.left)</span><br><span class="line">            min_num = <span class="built_in">min</span>(min_num,node.val-pre)</span><br><span class="line">            pre = node.val</span><br><span class="line">            f(node.right)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> min_num</span><br></pre></td></tr></table></figure>

<h3 id="（6）二叉搜索树中的搜索"><a href="#（6）二叉搜索树中的搜索" class="headerlink" title="（6）二叉搜索树中的搜索"></a>（6）二叉搜索树中的搜索</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（Leetcode）</a></strong></p>
<h3 id="（7）二叉搜索子树的最大键值和"><a href="#（7）二叉搜索子树的最大键值和" class="headerlink" title="（7）二叉搜索子树的最大键值和"></a>（7）二叉搜索子树的最大键值和</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和 - 力扣（Leetcode）</a></strong></p>
<h2 id="5-4-最近公共祖先"><a href="#5-4-最近公共祖先" class="headerlink" title="5.4 最近公共祖先"></a>5.4 最近公共祖先</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1W44y1Z7AR/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili</a></p>
<h3 id="（1）二叉树的最近公共祖先"><a href="#（1）二叉树的最近公共祖先" class="headerlink" title="（1）二叉树的最近公共祖先"></a>（1）二叉树的最近公共祖先</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（Leetcode）</a></strong></p>
<p>前序遍历，当前递归到的节点考虑有以下几种情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/18.png" alt="1"></p>
<blockquote>
<p>思考思考❗❗❗</p>
<p>为啥这么递归，有这些情况，是怎么想出来的呢❓</p>
</blockquote>
<h3 id="（2）二叉搜索树的最近公共祖先"><a href="#（2）二叉搜索树的最近公共祖先" class="headerlink" title="（2）二叉搜索树的最近公共祖先"></a>（2）二叉搜索树的最近公共祖先</h3><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（Leetcode）</a></strong></p>
<p>由于没有情况会遍历到空节点，所有不需要判断当前节点是否为空</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/19.png" alt="1"></p>
<p>这里利用了二叉搜索数的性质❗</p>
<ul>
<li>如果p和q都在左子树，那么最近公共祖先一定在左子树中</li>
<li>如果p和q都在右子树，那么最近公共祖先一定在右子树中</li>
<li>否则就是左子树一个，右子树一个，那么当前节点就是最近公共祖先【因为题目要求了p和q肯定存在】</li>
</ul>
<h2 id="5-5-二叉树的层序遍历【BFS】"><a href="#5-5-二叉树的层序遍历【BFS】" class="headerlink" title="5.5 二叉树的层序遍历【BFS】"></a>5.5 二叉树的层序遍历【BFS】</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hG4y1277i/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">二叉树的层序遍历【基础算法精讲 13】_哔哩哔哩_bilibili</a></p>
<p><strong>两种方法：</strong></p>
<ul>
<li>利用了双数组❗</li>
<li>可以将两个数组拼起来，使用队列❗</li>
</ul>
<p>递归的算法是DFS【深度优先搜索】，使用一个栈，进行入栈和出栈的操作，这些操作计算机内部自动实现了，代码比较简洁。</p>
<p>层序遍历的算法是BFS【广度优先搜索】，使用一个队列，进行入队和出队的操，这里需要手动操作。</p>
<p><strong>相关题目：</strong></p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历 - 力扣（Leetcode）</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（Leetcode）</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></strong></li>
</ul>
<h1 id="六、回溯"><a href="#六、回溯" class="headerlink" title="六、回溯"></a>六、回溯</h1><h2 id="什么是回溯❓❓❓"><a href="#什么是回溯❓❓❓" class="headerlink" title="什么是回溯❓❓❓"></a>什么是回溯❓❓❓</h2><details class="folding-tag" blue><summary> 什么是回溯 </summary>
              <div class='content'>
              <p><strong>题目：</strong></p><p>构造长为n的字符串。</p><p><strong>思路：</strong></p><ul><li>原问题：构造长为n的字符串</li><li>枚举一个字母</li><li>构造长为n-1的字符串</li></ul><p>子问题和原问题是相似的，这种从原问题到子问题的过程，适合用递归解决，通过递归就可以达到多重循环的效果。</p><p>例如从abc中选一个字母，从dcf中选一个字母两两组合。</p><p>回溯有一个增量构造答案的过程，这个过程通常用递归实现。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/20.png" alt="1"></p><p>有同学在思考递归过程的时候，可能会想怎么递的和怎么归的，这个递归代码到底对不对，其实只要边界条件和非边界条件的逻辑写对了，其他的工作交给数学归纳法就可。</p><p>因此在思考回溯问题的时候，只需要将头部的逻辑想明白就行。</p>
              </div>
            </details>

<h2 id="模板🤓"><a href="#模板🤓" class="headerlink" title="模板🤓"></a>模板🤓</h2><p><strong>回溯三问：</strong></p>
<ul>
<li>首先想想当前操作是什么，或者说每一步的操作是要干什么？</li>
<li>子问题？或者说是当前的问题是什么</li>
<li>下一个子问题？当操作完一步后，下一个子问题是什么？</li>
</ul>
<p><strong>相关练习题：</strong></p>
<ol>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（Leetcode）</a></strong></li>
</ol>
<h2 id="💡子集型回溯"><a href="#💡子集型回溯" class="headerlink" title="💡子集型回溯"></a>💡子集型回溯</h2><details class="folding-tag" blue><summary> 子集 </summary>
              <div class='content'>
              <p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（Leetcode）</a></strong></p><p>下面是解决此类型问题的两种模板：</p><div class="tabs" id="子集"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#子集-1">站在输入的视角</button></li><li class="tab"><button type="button" data-href="#子集-2">站在答案的视角</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="子集-1"><p>每个元素可以选&#x2F;不选</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/21.png" alt="1"></p><p><strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []    <span class="comment"># 初始化最终结果</span></span><br><span class="line">        path = []   <span class="comment"># 初始化中间结果</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i==n:    <span class="comment"># 边界条件</span></span><br><span class="line">                <span class="comment"># path是全局变量是变化的，所有python要copy一下</span></span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 不选第i个数</span></span><br><span class="line">            dfs(i+<span class="number">1</span>)    <span class="comment"># 直接往下递归</span></span><br><span class="line">            <span class="comment"># 选第i个数</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            dfs(i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回上一步的状态</span></span><br><span class="line">            path.pop()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>每个元素只有选和不选两种状态，所有$O(2^N)$，copy()的时间是$O(n)$，所有时间复杂度就是$O(n*2^n)$</p><p><strong>空间复杂度：</strong>$O(n)$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="子集-2"><p>每次必须选一个数，枚举答案的第一个数选谁，第二个数选谁</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/22.png" alt="1"></p><p><strong>code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []    <span class="comment"># 初始化最终结果</span></span><br><span class="line">        path = []   <span class="comment"># 初始化中间结果</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            ans.append(path.copy())</span><br><span class="line">            <span class="keyword">if</span> i==n:    <span class="comment"># 边界条件</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                pa	th.append(nums[j])</span><br><span class="line">                dfs(j+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
              </div>
            </details>

<p><strong>相关习题：</strong></p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（Leetcode）</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列 - 力扣（Leetcode）</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/">1601. 最多可达成的换楼请求数目 - 力扣（Leetcode）</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数 - 力扣（Leetcode）</a></strong></p>
<blockquote>
<p>位运算</p>
</blockquote>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/additive-number/">306. 累加数 - 力扣（Leetcode）</a></strong></p>
</li>
</ul>
<h2 id="💡组合型回溯"><a href="#💡组合型回溯" class="headerlink" title="💡组合型回溯"></a>💡组合型回溯</h2><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xG4y1F7nC/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">回溯算法套路②组合型回溯+剪枝【基础算法精讲 15】_哔哩哔哩_bilibili</a></strong></p>
<p>组合型回溯就是从一组东西中，选出固定的几组，而不是选出全部的子集。</p>
<p>比如下面这道题：</p>
<details class="folding-tag" blue><summary> 组合 </summary>
              <div class='content'>
              <p>📌<strong>题目：</strong></p><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（Leetcode）</a></strong></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p><strong>📌思路：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/23.png" alt="1"></p><p>这题就是子集型问题的一种延申，</p><p>相比于子集问题，组合问题我们可以做一些额外的优化，图中所示：</p><p>在三个数中选三个数组合，我们从后往前递归，那么当第一个数不是3，而是2的时候，就不用往下递归了；</p><p>在三个数中选两个数组合，那么当长度已经是2了，也不需要往下递归了</p><blockquote><p>假设路径长度为<code>m</code>，那么就还需要选择<code>d-m</code>个数。</p><p>由于我们是从大到小枚举的，那么设当前需要从<code>[1,i]</code>这<code>i</code>个数中选数，</p><p>如果<code>i&lt;d</code>，那么必然无法选出<code>k</code>个数，不再需要递归，</p><p>这就是一种剪枝技巧。</p><ul><li>就是我们剪掉了这棵搜索树的一些分支，通过剪枝，我们可以缩小搜索树的规模。</li><li><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/345181624">什么是算法中的剪枝？ - 知乎 (zhihu.com)</a></strong></li></ul></blockquote><p>📌<strong>code：</strong></p><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#code-1">从答案的角度</button></li><li class="tab"><button type="button" data-href="#code-2">从输入的角度【选/不选】</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="code-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            d = k - <span class="built_in">len</span>(path)</span><br><span class="line">            <span class="keyword">if</span> i&lt;d:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) ==k:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 从结果的角度分析</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">                path.append(j)</span><br><span class="line">                dfs(j-<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="code-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            d = k - <span class="built_in">len</span>(path)</span><br><span class="line">            <span class="keyword">if</span> i&lt;d:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 从输入的角度</span></span><br><span class="line">            dfs(i-<span class="number">1</span>)</span><br><span class="line">            path.append(i)</span><br><span class="line">            dfs(i-<span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>📌<strong>时间复杂度：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/23.png" alt="1"></p><p>我们把每个叶子单独看，就是叶子的个数*根到叶子的路径长度，</p><blockquote><p>叶子个数就是从n个数中选k个数的组合的个数</p><p>路径长度就是递归的深度，也就是k</p></blockquote><p>$O(kC^k_n)$</p><p>空间复杂度为$O(k)$</p>
              </div>
            </details>

<p><strong>相关题目：</strong></p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III - 力扣（LeetCode）</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成 - 力扣（LeetCode）</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号 - 力扣（LeetCode）</a></strong></li>
</ul>
<h2 id="💡排列型回溯"><a href="#💡排列型回溯" class="headerlink" title="💡排列型回溯"></a>💡排列型回溯</h2><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mY411D7f6/?spm_id_from=333.788&vd_source=e459c0ddead0fb5eb6a33630a090aa93">回溯算法套路③排列型回溯+N皇后【基础算法精讲 16】_哔哩哔哩_bilibili</a></strong></p>
<details class="folding-tag" blue><summary> 全排列 </summary>
              <div class='content'>
              <p><strong>📌题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></strong></p><p>相比组合，排列型回溯中答案中的每一个元素都是相同的，只是顺序不同，我们要的是给出不同的排列组合。</p><p>那么$n$个数必有$n!$的排列组合。</p><p><strong>📌思路：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/25.png" alt="1"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/article_img/ACM/24.png" alt="1"></p><p>当然也可以用一个bool数组来标记是否已经添加到路径中了【自己写代码~】</p><p><strong>📌code：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []    <span class="comment"># 结果</span></span><br><span class="line">        path = []   <span class="comment"># 中间路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,s</span>):</span><br><span class="line">            <span class="keyword">if</span> i==n:    <span class="comment"># 全部数字排列完</span></span><br><span class="line">                ans.append(path.copy())     <span class="comment"># 路径添加到结果中</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> s: <span class="comment"># 枚举集合s中每一个元素，添加到路径中</span></span><br><span class="line">                path.append(x)</span><br><span class="line">                dfs(i+<span class="number">1</span>,s-&#123;x&#125;)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="built_in">set</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p><strong>相关习题：</strong></p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></strong></p>
<blockquote>
<p><strong>多做多做</strong>❗❗❗</p>
<p>鸽巢原理【抽屉原理】</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://blog.dai2yutou.space">小漁头&amp;小戴</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.dai2yutou.space/2023/06/07/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%B8%80%EF%BC%89/">http://blog.dai2yutou.space/2023/06/07/灵神基础算法精讲（一）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.dai2yutou.space" target="_blank">小漁头|小戴</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/">💭💡🎈</a></div><div class="post_share"><div class="social-share" data-image="https://picbed.dai2yutou.space/web_img/28.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/30/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于时间片轮转的进程管理系统的设计与实现</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/17/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/28.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">灵神基础算法精讲（二）【如何学习动态规划？？？】</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/17/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%BA%8C%EF%BC%89/" title="灵神基础算法精讲（二）【如何学习动态规划？？？】"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/28.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">灵神基础算法精讲（二）【如何学习动态规划？？？】</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="animate__fadeIn card-info card-widget wow" data-wow-delay="0" data-wow-duration="" data-wow-iteration="" data-wow-offset="" style="visibility: visible; animation-name: fadeIn;"><div class="author-info-top"><div class="card-info-avatar"><a class="avatar-img" data-pjax-state="" href="/about"><img class="entered loaded" alt="avatar" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/apple-touch-icon.jpg" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;"/></a><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="/img/tree_icon.png">🐟</g-emoji><span>摸鱼中~</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi">晚安😴！我是</div><h1 class="author-info__name">XiaoYutou|XiaoDai</h1><div class="author-info__description">热爱生活点滴，分享时刻精彩。</div><a id="card-info-btn" data-pjax-state="" onclick="pjax.loadUrl(/about/)"><i></i><span style="padding-left:32px;font-weight:600;font-size:large">了解更多<i class="faa-passing animated" style="padding-left:-2px;display:inline-block;vertical-align:middle;"><span style="height:28px;width:28px;fill:currentColor;position:relative;top:-1.5px">💨</span></i></span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xiaoyutoua" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2143191301@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名:<a target="_blank" rel="noopener" href="https://www.dai2yutou.space">小漁头|小戴</a><br><span>技术问题欢迎交流🧐</span><span color="#3eb8be">VX:yuguolong_001</span></center></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%90%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%91"><span class="toc-text">一、同向双指针【滑动窗口】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E4%B8%80%E4%B8%AA%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-text">来一个例题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="toc-text">相关题目：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">二、相向双指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">三、二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-text">💡循环不变量：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-text">💡相关题目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">四、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">4.1 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-text">4.2 快慢指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88"><span class="toc-text">4.3 前后指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">五、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E9%80%92%E5%BD%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%91"><span class="toc-text">5.1 二叉树的递归【计算机执行递归底层原理】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E7%9A%84%E8%BF%90%E7%94%A8%E9%80%92%E5%BD%92%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="toc-text">5.2 如何灵活的运用递归？？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST"><span class="toc-text">5.3 二叉搜索树BST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%9D%93"><span class="toc-text">（1）什么是二叉搜索树❓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%9D%93"><span class="toc-text">（2）如何判断一棵树是不是二叉搜索树❓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">（3）二叉搜索树中第k小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">（4）二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">（5）二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">（6）二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C"><span class="toc-text">（7）二叉搜索子树的最大键值和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">5.4 最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">（1）二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">（2）二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%90BFS%E3%80%91"><span class="toc-text">5.5 二叉树的层序遍历【BFS】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9B%9E%E6%BA%AF"><span class="toc-text">六、回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E2%9D%93%E2%9D%93%E2%9D%93"><span class="toc-text">什么是回溯❓❓❓</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%F0%9F%A4%93"><span class="toc-text">模板🤓</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E5%AD%90%E9%9B%86%E5%9E%8B%E5%9B%9E%E6%BA%AF"><span class="toc-text">💡子集型回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E7%BB%84%E5%90%88%E5%9E%8B%E5%9B%9E%E6%BA%AF"><span class="toc-text">💡组合型回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E6%8E%92%E5%88%97%E5%9E%8B%E5%9B%9E%E6%BA%AF"><span class="toc-text">💡排列型回溯</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/17/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%BA%8C%EF%BC%89/" title="灵神基础算法精讲（二）【如何学习动态规划？？？】"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/28.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="灵神基础算法精讲（二）【如何学习动态规划？？？】"/></a><div class="content"><a class="title" href="/2023/07/17/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%BA%8C%EF%BC%89/" title="灵神基础算法精讲（二）【如何学习动态规划？？？】">灵神基础算法精讲（二）【如何学习动态规划？？？】</a><time datetime="2023-07-17T15:54:48.000Z" title="发表于 2023-07-17 23:54:48">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/07/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%B8%80%EF%BC%89/" title="灵神基础算法精讲（一）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/28.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="灵神基础算法精讲（一）"/></a><div class="content"><a class="title" href="/2023/06/07/%E7%81%B5%E7%A5%9E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88%E4%B8%80%EF%BC%89/" title="灵神基础算法精讲（一）">灵神基础算法精讲（一）</a><time datetime="2023-06-07T15:58:25.000Z" title="发表于 2023-06-07 23:58:25">2023-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="基于时间片轮转的进程管理系统的设计与实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于时间片轮转的进程管理系统的设计与实现"/></a><div class="content"><a class="title" href="/2023/05/30/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="基于时间片轮转的进程管理系统的设计与实现">基于时间片轮转的进程管理系统的设计与实现</a><time datetime="2023-05-30T15:25:36.000Z" title="发表于 2023-05-30 23:25:36">2023-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 小漁头&小戴</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/starry_sky.js"></script><script defer src="/js/console.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script async data-pjax src="/js/card_author.js"></script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JzK9w99AgP1g6fso",ck:"JzK9w99AgP1g6fso"})</script><script type="text/javascript" src ="/js/reward.js" ></script><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.6.16/dist/sweetalert2.all.min.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInRight');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/02/论文翻译/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/3.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/02/论文翻译/&quot;);" href="javascript:void(0);" alt="">英文水平不高，咋翻译论文？</a><div class="blog-slider__text">英文水平不高，咋翻译论文？</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/02/论文翻译/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/12/17/博客搭建学习笔记/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/web_background2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-12-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/12/17/博客搭建学习笔记/&quot;);" href="javascript:void(0);" alt="">🐌博客搭建学习笔记</a><div class="blog-slider__text">这是再搭建博客已经写文章时遇到的bug和对博客的一些必要操作，不定时更新哦~</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/12/17/博客搭建学习笔记/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/Butterfly外挂标签/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/9.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/Butterfly外挂标签/&quot;);" href="javascript:void(0);" alt="">Butterfly外挂标签</a><div class="blog-slider__text">本文是撰写博客文章时可能会用到的外挂标签汇总，放到一起，便于查阅和使用</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/Butterfly外挂标签/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/12/09/hello-world/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/2.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-12-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/12/09/hello-world/&quot;);" href="javascript:void(0);" alt="">第一篇文章</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/12/09/hello-world/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/erro_spawn_failed/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/7.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/erro_spawn_failed/&quot;);" href="javascript:void(0);" alt="">Hexo发生error：spawn failed错误的解决方法</a><div class="blog-slider__text">Hexo发生error：spawn failed错误的解决方法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/erro_spawn_failed/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/06/Hexo博客备份与恢复/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/7.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/06/Hexo博客备份与恢复/&quot;);" href="javascript:void(0);" alt="">Hexo博客备份与恢复</a><div class="blog-slider__text">本文旨在解决在不同电脑上都能维护博客或配置、发布的内容丢失可恢复的问题。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/06/Hexo博客备份与恢复/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/24/Echarts社区地址/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.dai2yutou.space/web_img/10.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/24/Echarts社区地址/&quot;);" href="javascript:void(0);" alt="">Echarts社区地址</a><div class="blog-slider__text">一些Echarts图标的开源网站。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/24/Echarts社区地址/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.dai2yutou.space/api?xiaoyutoua",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'xiaoyutoua')
    }
  </script><!-- hexo injector body_end end --><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>